1. Defining project requirements and scope
  - How many users should the app support?
  - What kinds of features should the program have?
  - What kind of security do we need to consider?
  - How much will this all cost?
  - How long should it take?
2. Design 
  - What language should be used?
  - What frameworks?
  - How should the front end be built? What about the back end?
  - Creating a UI/UX prototype
  - What components need to be built?
  - What endpoints need to be made?
  - What database models?
3. Development
  - The longest and most expensive phase
  - The features outlined in the design process are created incrementally
  - Done through implementation of one of several project management methodologies
    - Agile - series of short sprints of incremental improvements. Hit Minimum Viable Product (MVP) fast, then iterate on the project and continue adding features as times goes on.
      - Pros: faster time to market, quicker turnaround to user feedback, easier to pivot and change direction
      - Cons: stress, feature barren at launch, the never ending story
    - Waterfall - longer, more thorough process. Design all features, and implement all features before release.
      - Pros: More complete product at launch, somewhat less stressful, with a more definitive "end" to the project.
      - Cons: Takes much longer, meaning more time and money spent with no revenue, much harder to pivot or react to feedback.
4. Testing
  - Quality assurance engineers put the application through the ringer.
  - Effectively the last line of defense before users get their hands on new applications/features.
  - Ensuring that the final product aligns with the original design and scope.
5. Deployment
  - The application is delivered to users through the appropriate channels. Web applications are hosted on servers, mobile applications are loaded onto their respective marketplaces, games are published, etc.
  - This phase is managed by Developer Operations Engineers (the DevOps team).
  - Monitor the production application
6. Maintenance
  - The hardest part (creating the actual application) is done. But bugs are bugs. They need to be squashed.
  - User feedback might bring up the need for some new feature, or additional clarification, etc.
  - Library deprecations or new frameworks require or provide alternative options that might be better
